# Database Architecture Documentation

## Overview

This document explains the database schema design decisions for the MailEye email infrastructure management system.

---

## DNS Record Storage Strategy

### Current Implementation

All DNS records (SPF, DKIM, DMARC, MX, CNAME, etc.) are stored in a single **`dns_records`** table with a flexible schema:

```sql
CREATE TABLE dns_records (
  id UUID PRIMARY KEY,
  domain_id UUID NOT NULL,
  record_type VARCHAR(10) NOT NULL,  -- 'A', 'MX', 'TXT', 'CNAME', 'SPF', 'DKIM', 'DMARC'
  name VARCHAR(255) NOT NULL,
  value TEXT NOT NULL,
  ttl INTEGER DEFAULT 3600,
  priority INTEGER,
  status VARCHAR(20) NOT NULL DEFAULT 'pending',
  purpose VARCHAR(50),  -- 'email_verification', 'spf', 'dkim', 'dmarc', 'mx', 'custom'
  metadata JSONB,  -- Flexible storage for record-specific data
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
);
```

**Key Features:**
- **`purpose` field**: Categorizes DNS records by function (`spf`, `dkim`, `dmarc`, `mx`, `tracking`, `custom`)
- **`metadata` JSONB field**: Stores additional record-specific data without requiring new columns
- **Single source of truth**: All DNS records in one table, simplifying queries and management

---

## Specialized Tables (CURRENTLY UNUSED)

The following specialized tables were designed but are **NOT currently being used** in the application:

### 1. `spf_records` (Unused)

**Purpose:** Store SPF flattening metadata (lookup counts, flattening strategy, expanded IPs)

**Status:** ❌ Not used - SPF flattening results are calculated on-demand but not saved to database

**Schema:**
```sql
CREATE TABLE spf_records (
  id UUID PRIMARY KEY,
  domain_id UUID NOT NULL,
  raw_record TEXT NOT NULL,
  flattened_record TEXT,
  is_flattened BOOLEAN DEFAULT FALSE,
  mechanism_count INTEGER DEFAULT 0,
  include_count INTEGER DEFAULT 0,
  lookup_count INTEGER DEFAULT 0,
  is_valid BOOLEAN DEFAULT FALSE,
  validation_errors JSONB,
  flattening_strategy VARCHAR(50),
  expanded_ips JSONB,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
);
```

**Why unused:**
- SPF flattening is performed in `server/dns/spf-flattener.ts`
- Results are returned as function output, not saved to database
- SPF records are stored in `dns_records` table with basic content only
- Flattening metadata (lookup counts, expanded IPs) is not persisted

### 2. `dmarc_records` (Unused)

**Purpose:** Store DMARC policy details (alignment modes, reporting configuration)

**Status:** ❌ Not used - DMARC records are stored in `dns_records` only

**Schema:**
```sql
CREATE TABLE dmarc_records (
  id UUID PRIMARY KEY,
  domain_id UUID NOT NULL,
  raw_record TEXT NOT NULL,
  policy VARCHAR(20) NOT NULL,  -- 'none', 'quarantine', 'reject'
  subdomain_policy VARCHAR(20),
  percentage INTEGER DEFAULT 100,
  spf_alignment VARCHAR(10) DEFAULT 'r',
  dkim_alignment VARCHAR(10) DEFAULT 'r',
  aggregate_report_email VARCHAR(255),
  forensic_report_email VARCHAR(255),
  report_format VARCHAR(10) DEFAULT 'afrf',
  reporting_interval INTEGER DEFAULT 86400,
  is_valid BOOLEAN DEFAULT FALSE,
  validation_errors JSONB,
  parsed_tags JSONB,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
);
```

**Why unused:**
- DMARC records are generated in `server/dns/dmarc-generator.ts`
- Result is saved to `dns_records` table with purpose='dmarc'
- Policy details and configuration are not separately tracked in database

### 3. `dkim_records` (Unused)

**Purpose:** Store DKIM selectors, public keys, and key management metadata

**Status:** ❌ Not used - DKIM records are stored in `dns_records` only

**Schema:**
```sql
CREATE TABLE dkim_records (
  id UUID PRIMARY KEY,
  domain_id UUID NOT NULL,
  selector VARCHAR(255) NOT NULL,  -- e.g., 'default', 'google', 'k1'
  public_key TEXT NOT NULL,
  private_key TEXT,  -- Optional encrypted private key storage
  algorithm VARCHAR(20) DEFAULT 'rsa-sha256',
  key_type VARCHAR(10) DEFAULT 'rsa',
  key_length INTEGER,
  is_active BOOLEAN DEFAULT TRUE,
  last_checked_at TIMESTAMPTZ,
  is_valid BOOLEAN DEFAULT FALSE,
  validation_errors JSONB,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  UNIQUE(domain_id, selector)
);
```

**Why unused:**
- DKIM records are created via Google Workspace integration
- Records are retrieved from Google Admin SDK, not generated by our system
- DKIM public keys are stored in `dns_records` table with purpose='dkim'
- Key management and validation are handled by Google Workspace

### 4. `smartlead_sync_logs` (Unused)

**Purpose:** Audit trail of Smartlead synchronization events

**Status:** ❌ Not used - Referenced in batch operations but no actual syncing implemented yet

**Schema:**
```sql
CREATE TABLE smartlead_sync_logs (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  sync_type VARCHAR(50) NOT NULL,  -- 'full_sync', 'incremental_sync', 'account_import'
  direction VARCHAR(10) NOT NULL,  -- 'import', 'export', 'bidirectional'
  status VARCHAR(20) NOT NULL,  -- 'success', 'failed', 'partial'
  accounts_processed JSONB,
  changes_applied JSONB,
  errors JSONB,
  error_message TEXT,
  started_at TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  metadata JSONB,
  created_at TIMESTAMPTZ
);
```

**Why unused:**
- Smartlead integration exists but automated sync not implemented
- Manual email account connections supported via `smartlead_account_mappings`
- Sync logging will be implemented when automated sync is added

---

## Decision: Keep or Remove Unused Tables?

### Option A: Remove Unused Tables (Recommended)

**Pros:**
- Cleaner database schema
- Reduces confusion for developers
- Simpler migrations and backups
- No maintenance burden for unused code

**Cons:**
- Need to recreate tables if features are added later
- Lose the detailed schema documentation embedded in table definitions

### Option B: Keep Unused Tables

**Pros:**
- Ready to use if features are implemented
- Detailed schema already designed and validated
- No need to redesign when features are added

**Cons:**
- Clutters database with empty tables
- Developers may think tables are in use
- Schema drift risk if not maintained

### Recommendation: **Option A - Remove Unused Tables**

**Rationale:**
1. The `dns_records.metadata` JSONB field can store any specialized data if needed
2. Specialized tables can be recreated later if a feature requires them
3. Simpler is better - only maintain tables that are actively used
4. Version control preserves the table schemas for future reference

---

## Tables Currently In Use

### Core Email Infrastructure

1. **`domains`** - Domain management and status tracking
2. **`dns_records`** - All DNS records (SPF, DKIM, DMARC, MX, etc.)
3. **`email_accounts`** - Email account provisioning and warmup tracking
4. **`warmup_schedule`** - Daily warmup progression for email accounts
5. **`email_activity_log`** - Email sending activity and analytics

### Batch Operations

6. **`batch_operations`** - Batch job tracking (email provisioning, DNS setup)
7. **`batch_operation_items`** - Individual items within batch operations

### Smartlead Integration

8. **`smartlead_config`** - User API configuration for Smartlead
9. **`smartlead_account_mappings`** - Links local email accounts to Smartlead accounts

---

## Database Usage Examples

### Storing SPF Records

```typescript
// SPF record is saved to dns_records with metadata
await db.insert(dnsRecords).values({
  domainId: 'domain-123',
  recordType: 'TXT',
  name: '@',
  value: 'v=spf1 include:_spf.google.com ~all',
  purpose: 'spf',
  metadata: {
    emailPlatform: 'google-workspace',
    includes: ['_spf.google.com'],
    // Could add flattening data here if needed:
    // lookupCount: 1,
    // isFlattened: false,
  },
});
```

### Storing DMARC Records

```typescript
// DMARC record saved to dns_records
await db.insert(dnsRecords).values({
  domainId: 'domain-123',
  recordType: 'TXT',
  name: '_dmarc',
  value: 'v=DMARC1; p=none; rua=mailto:dmarc@example.com',
  purpose: 'dmarc',
  metadata: {
    policy: 'none',
    aggregateReportEmail: 'dmarc@example.com',
    // Could add parsed policy details here if needed:
    // spfAlignment: 'r',
    // dkimAlignment: 'r',
    // percentage: 100,
  },
});
```

### Querying DNS Records by Purpose

```typescript
// Get all SPF records for a domain
const spfRecords = await db
  .select()
  .from(dnsRecords)
  .where(
    and(
      eq(dnsRecords.domainId, domainId),
      eq(dnsRecords.purpose, 'spf')
    )
  );

// Get all email-related DNS records
const emailRecords = await db
  .select()
  .from(dnsRecords)
  .where(
    and(
      eq(dnsRecords.domainId, domainId),
      inArray(dnsRecords.purpose, ['spf', 'dkim', 'dmarc', 'mx'])
    )
  );
```

---

## Future Considerations

### If SPF Flattening Metadata is Needed

Instead of using the `spf_records` table, store flattening data in `dns_records.metadata`:

```typescript
await db.insert(dnsRecords).values({
  domainId: 'domain-123',
  recordType: 'TXT',
  name: '@',
  value: 'v=spf1 ip4:1.2.3.4 ip4:5.6.7.8 ~all',  // Flattened record
  purpose: 'spf',
  metadata: {
    originalRecord: 'v=spf1 include:_spf.google.com include:sendgrid.net ~all',
    isFlattened: true,
    flatteningStrategy: 'ip_expansion',
    lookupCountBefore: 5,
    lookupCountAfter: 0,
    expandedIps: ['1.2.3.4', '5.6.7.8'],
    flattenedAt: new Date().toISOString(),
  },
});
```

This approach:
- ✅ Keeps all DNS records in one table
- ✅ Allows flexible metadata storage without schema changes
- ✅ Simplifies queries (no joins required)
- ✅ Maintains backward compatibility

---

## Migration Plan (If Removing Unused Tables)

### Step 1: Verify Tables are Unused

```sql
-- Check if any data exists in unused tables
SELECT COUNT(*) FROM spf_records;
SELECT COUNT(*) FROM dmarc_records;
SELECT COUNT(*) FROM dkim_records;
SELECT COUNT(*) FROM smartlead_sync_logs;
```

### Step 2: Remove Import References

Search codebase for imports of unused tables:

```bash
grep -r "spfRecords" server/
grep -r "dmarcRecords" server/
grep -r "dkimRecords" server/
```

Remove any unused imports from:
- `lib/db/schema.ts` (re-export statements)
- `server/dns/spf-flattener.ts` (line 23)

### Step 3: Create Migration

```sql
-- Migration: remove_unused_dns_tables
DROP TABLE IF EXISTS spf_records;
DROP TABLE IF EXISTS dmarc_records;
DROP TABLE IF EXISTS dkim_records;
DROP TABLE IF EXISTS smartlead_sync_logs;
```

### Step 4: Update Documentation

- ✅ This file documents the decision and rationale
- Update `lib/db/schema.ts` to remove unused table exports
- Update any architecture diagrams to show current schema only

---

## Conclusion

**Current Status:**
- ✅ `dns_records` table handles all DNS record storage
- ❌ `spf_records`, `dmarc_records`, `dkim_records` are unused
- ❌ `smartlead_sync_logs` is unused (sync not implemented)

**Recommendation:**
- Remove unused specialized tables
- Use `dns_records.metadata` for any additional data needs
- Recreate specialized tables only if a feature requires complex querying or indexing

**Benefits:**
- Simpler schema maintenance
- Clearer codebase for developers
- Faster database operations (fewer tables to scan)
- More flexible metadata storage

---

## Version History

- **v1.0** (2025-01-16): Initial database architecture analysis and recommendations
